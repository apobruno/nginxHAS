<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Ritual Chains ‚Äî Prot√≥tipo Completo (5√ó5)</title>
  <style>
    :root{
      --bg:#0e0f12; --panel:#151821; --panel2:#10131a; --text:#e9ecf1; --muted:#9aa3b2;
      --line:#2a3142; --accent:#7aa2ff; --good:#7CFFB2; --bad:#ff7a7a; --warn:#ffd27a;
      --chip:#0f1420;
      --tipbg:#0a0d14; --tipline:#1e2637;
      --overlay: rgba(0,0,0,.6);
    }
    body{ margin:16px; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; background:var(--bg); color:var(--text); }
    h1{ font-size:18px; margin:0; }
    .topbar{
      display:flex; align-items:center; justify-content:space-between;
      gap:12px; margin-bottom:10px;
    }
    .topbar .right{ display:flex; gap:10px; align-items:center; }
    .helpBtn{
      width:38px; height:38px; border-radius:12px;
      display:inline-flex; align-items:center; justify-content:center;
      border:1px solid var(--line); background:#111826; color:var(--text);
      cursor:pointer;
      font-weight:900;
    }
    .helpBtn:hover{ border-color:#3a4660; }

    .panel{ background:var(--panel); border:1px solid var(--line); border-radius:14px; padding:12px; }
    .panel h2{ margin:0 0 8px; font-size:14px; color:#d8ddff; }
    .stats{ display:flex; gap:10px; flex-wrap:wrap; color:var(--muted); font-size:12px; margin-bottom:10px; }
    .pill{ display:inline-flex; gap:8px; align-items:center; padding:6px 10px; border-radius:999px;
      border:1px solid var(--line); background:var(--chip); color:var(--muted); font-size:12px; }
    .pill b{ color:var(--text); }
    button{
      background:#111826; color:var(--text); border:1px solid var(--line);
      padding:10px 12px; border-radius:12px; cursor:pointer;
    }
    button:hover{ border-color:#3a4660; }
    button.primary{ background:var(--accent); color:#081022; border-color:#90b2ff; font-weight:800; }
    button.danger{ background:#2a1416; border-color:#5a2a32; color:#ffb3b3; }
    button.ghost{ background:transparent; }
    button:disabled{ opacity:.5; cursor:not-allowed; }
    .hint{ color:var(--muted); font-size:12px; margin-top:6px; }
    .cols{ display:flex; gap:12px; flex-wrap:wrap; }
    .col{ flex: 1 1 520px; min-width: 330px; }

    .grid{
      display:grid; grid-template-columns: repeat(5, 78px); grid-template-rows: repeat(5, 78px);
      gap:8px; padding:8px; background:var(--panel2); border-radius:14px; border:1px solid var(--line);
    }
    .cell{
      position:relative; border:1px dashed #2c3550; border-radius:14px;
      display:flex; align-items:center; justify-content:center; text-align:center;
      background:rgba(255,255,255,0.03);
      user-select:none;
      overflow: visible;
    }
    .cell.target{ border-style:solid; border-color:#5c4bff; box-shadow:0 0 0 1px rgba(92,75,255,.25) inset; }
    .cell.blocked{
      border-style:solid; border-color:#5a2a32;
      background:rgba(255, 122, 122, .08);
    }
    .cell .coord{ position:absolute; top:6px; left:8px; font-size:10px; color:#6e7891; }
    .cell .badge{ position:absolute; bottom:6px; right:8px; font-size:10px; color:#6e7891; }
    .cell .mini{ font-size:11px; color:var(--muted); }
    .cell .blockedMark{
      position:absolute; inset:0;
      display:flex; align-items:center; justify-content:center;
      font-weight:1000; font-size:22px; color:rgba(255, 122, 122, .65);
      pointer-events:none;
    }

    .card{
      width: 150px; border-radius:14px; border:1px solid var(--line);
      background:#0f1420; padding:10px; cursor:pointer;
      display:flex; flex-direction:column; gap:6px;
      position: relative;
      overflow: visible;
    }
    .card:hover{ border-color:#3a4660; }
    .card.selected{ outline:2px solid var(--accent); }
    .card .top{ display:flex; justify-content:space-between; align-items:center; gap:8px; }
    .tag{ font-size:10px; padding:3px 8px; border-radius:999px; border:1px solid var(--line); color:var(--muted); }
    .tag.rune{ border-color:#2f4a3a; color:#aef1c7; }
    .tag.concept{ border-color:#4a3a2f; color:#ffd9ae; }
    .title{ font-weight:900; letter-spacing:.3px; }
    .sub{ font-size:12px; color:var(--muted); }
    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; font-size:12px; }
    .hand{ display:flex; gap:10px; flex-wrap:wrap; }
    .log{ white-space:pre-wrap; font-size:12px; color:#d9def0; background:#0a0d14; border:1px solid #1e2637; border-radius:14px; padding:10px; max-height:380px; overflow:auto; }
    .small{ font-size:11px; color:var(--muted); }
    .kbd{ display:inline-block; padding:1px 6px; border:1px solid var(--line); border-radius:6px; background:#0c1018; color:#cfd6e6; font-size:11px; }

    /* Tooltip */
    [data-tip] { position: relative; }
    [data-tip]:hover::after{
      content: attr(data-tip);
      position: absolute;
      z-index: 50;
      left: 50%;
      bottom: calc(100% + 8px);
      transform: translateX(-50%);
      background: var(--tipbg);
      color: var(--text);
      border: 1px solid var(--tipline);
      border-radius: 10px;
      padding: 8px 10px;
      width: 260px;
      white-space: pre-wrap;
      font-size: 12px;
      line-height: 1.25;
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
      pointer-events: none;
    }
    [data-tip]:hover::before{
      content: "";
      position: absolute;
      z-index: 51;
      left: 50%;
      bottom: calc(100% + 2px);
      transform: translateX(-50%);
      border: 6px solid transparent;
      border-top-color: var(--tipline);
      pointer-events: none;
    }

    /* Modals */
    .modalOverlay{
      position:fixed; inset:0; background:var(--overlay);
      display:none; align-items:center; justify-content:center;
      z-index: 200;
      padding: 18px;
    }
    .modal{
      width:min(820px, 96vw);
      background: #0a0d14;
      border:1px solid #1e2637;
      border-radius:16px;
      box-shadow: 0 20px 60px rgba(0,0,0,.55);
      overflow:hidden;
    }
    .modalHeader{
      padding: 14px 16px;
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      border-bottom:1px solid #1e2637;
      background: #0d111a;
    }
    .modalHeader h3{ margin:0; font-size:14px; color:#d8ddff; }
    .modalBody{ padding: 14px 16px; color:#d9def0; font-size:13px; line-height:1.35; }
    .modalFooter{
      padding: 12px 16px;
      border-top:1px solid #1e2637;
      display:flex; justify-content:flex-end; gap:10px; flex-wrap:wrap;
      background:#0d111a;
    }
    .rewardGrid{
      display:grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 10px;
      margin-top: 10px;
    }
    .rewardCard{
      border:1px solid #1e2637;
      background:#0f1420;
      border-radius:14px;
      padding: 12px;
      cursor:pointer;
      min-height: 120px;
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .rewardCard:hover{ border-color:#3a4660; }
    .rewardTitle{ font-weight:900; color:#e9ecf1; }
    .rewardDesc{ color:#b7bfd2; font-size:12px; white-space:pre-wrap; }
    .rewardTag{
      align-self:flex-start;
      font-size:10px;
      padding:3px 8px;
      border-radius:999px;
      border:1px solid #2a3142;
      color:#9aa3b2;
    }
    .rewardTag.common{ border-color:#2f4a3a; color:#aef1c7; }
    .rewardTag.uncommon{ border-color:#4a3a2f; color:#ffd9ae; }
    .rewardTag.rare{ border-color:#3b2a55; color:#d6c7ff; }
    .rewardTag.mythic{ border-color:#5a2a32; color:#ffb3b3; }
    .muted{ color:var(--muted); }
  </style>
</head>
<body>
  <div class="topbar">
    <h1>Ritual Chains ‚Äî Prot√≥tipo Completo (5√ó5)</h1>
    <div class="right">
      <button id="helpBtn" class="helpBtn" title="Help">?</button>
    </div>
  </div>

  <div class="cols">
    <div class="panel col">
      <h2>Tabuleiro</h2>
      <div id="grid" class="grid"></div>
      <div class="hint">
        <b>Como jogar:</b> clique numa carta da m√£o para selecionar ‚Üí clique numa c√©lula vazia para colocar.<br/>
        Clique numa carta no tabuleiro para remover (volta para a m√£o).<br/>
        Por rodada voc√™ pode colocar no m√°ximo <span class="kbd">5</span> cartas novas. Depois clique <b>Resolver</b>.
      </div>
    </div>

    <div class="panel col">
      <h2>Controles</h2>

      <div class="stats">
        <div class="pill">N√≠vel: <b id="levelVal">1</b></div>
        <div class="pill">Rompimentos: <b id="breaksVal">0</b></div>
        <div class="pill">B√¥nus global aura: <b id="globalAuraVal">0</b></div>
        <div class="pill">Vidas: <b id="livesVal">0</b></div>
        <div class="pill">Limiar: <b id="thresholdVal">70</b></div>
        <div class="pill">Cartas nesta rodada: <b id="placedThisMove">0</b> / 5</div>

        <div class="pill">Mult Flush: <b id="mFlush">1.4</b></div>
        <div class="pill">Mult Straight: <b id="mStraight">1.2</b></div>
        <div class="pill">Mult SF: <b id="mSF">1.7</b></div>
        <div class="pill">ECO√ó: <b id="mEco">2.0</b></div>
        <div class="pill">REVERB√ó: <b id="mReverb">2.0</b></div>
        <div class="pill">Flush min: <b id="flushMin">5</b></div>

        <div class="pill">Deck: <b id="deckCount">0</b></div>
        <div class="pill">Descarte: <b id="discardCount">0</b></div>
        <div class="pill">M√£o: <b id="handCount">0</b> / 9</div>
        <div class="pill">Conceitos no grid: <b id="conceptsOnGrid">0</b></div>
      </div>

      <div style="display:flex; gap:10px; flex-wrap:wrap; margin-bottom:10px;">
        <button id="btnDraw">Comprar at√© 9</button>
        <button id="btnMulligan">Mulligan (m√£o inteira)</button>
        <button id="btnResolve" class="primary">Resolver (fim da rodada)</button>
        <button id="btnClearAllRunes" class="ghost">Remover Runas do grid</button>
        <button id="btnReset" class="danger">Reset Geral</button>
      </div>

      <div class="hint">
        <b>Amplificadores liberados:</b> ECO e REVERB podem ativar <b>v√°rias vezes</b> na mesma chain (stackando).
      </div>

      <h2 style="margin-top:12px;">M√£o (9)</h2>
      <div id="hand" class="hand"></div>

      <h2 style="margin-top:12px;">Log</h2>
      <div id="log" class="log">‚Äî</div>
    </div>
  </div>

  <!-- Help modal -->
  <div id="helpOverlay" class="modalOverlay">
    <div class="modal">
      <div class="modalHeader">
        <h3>Help ‚Äî Como funciona</h3>
        <button id="helpClose" class="ghost">Fechar</button>
      </div>
      <div class="modalBody">
        <div class="mono">
<b>Objetivo</b>
‚Ä¢ Construa chains da borda at√© a Casa Dissonante.
‚Ä¢ Se scaled √ó10 ‚â• limiar, voc√™ causa um rompimento.
‚Ä¢ Rompimentos s√£o infinitos: limiar come√ßa em 70 e aumenta +70 a cada rompimento.

<b>Dificuldade</b>
‚Ä¢ A cada rompimento: todas as runas +1 aura (b√¥nus global acumulativo).

<b>Vidas</b>
‚Ä¢ Voc√™ come√ßa com 6 vidas.
‚Ä¢ Se n√£o romper, perde 1 vida.

<b>Recompensas</b>
‚Ä¢ A cada rompimento: escolha 1 de 3.
  - Fortificar runa: +2 aura (espec√≠fica)
  - +0,1 em mult de Flush/Straight
  - +0,1 em ECO/REVERB
  - Estilos (at√© 3 na run)

<b>Amplificadores (ECO/REVERB)</b>
‚Ä¢ Podem ativar m√∫ltiplas vezes na mesma chain (stackando).
        </div>
      </div>
      <div class="modalFooter">
        <button id="helpClose2" class="primary">Entendi</button>
      </div>
    </div>
  </div>

  <!-- Reward modal -->
  <div id="rewardOverlay" class="modalOverlay">
    <div class="modal">
      <div class="modalHeader">
        <h3 id="rewardTitle">Recompensa</h3>
        <span class="muted mono" id="rewardSubtitle">‚Äî</span>
      </div>
      <div class="modalBody">
        <div class="mono">Escolha <b>1</b> recompensa para continuar.</div>
        <div id="rewardGrid" class="rewardGrid"></div>
        <div class="hint">Recompensas alteram esta run permanentemente.</div>
      </div>
      <div class="modalFooter">
        <button id="rewardSkip" class="ghost" title="N√£o recomendado">Pular (debug)</button>
      </div>
    </div>
  </div>

<script>
/* ===== Constants ===== */
const N = 5;
const HAND_MAX = 9;
const BASE_LIVES = 6;

const BASE_THRESHOLD = 70;
const THRESHOLD_STEP = 70;

const DIRS = ['U','R','D','L'];
const DELTA = { U:[-1,0], R:[0,1], D:[1,0], L:[0,-1] };
const ROT_PENALTY_PER_TURN = 0.25;

const RUNES = ['VAR','AEL','LUM','RHE','SOL','NOX'];
const CONCEPTS_12 = [
  { name:'DESVIO', dirs:['L','R'] },
  { name:'DESVIO', dirs:['L','R'] },
  { name:'CURVATURA', dirs:['U','R'] },
  { name:'CURVATURA', dirs:['U','R'] },
  { name:'CRUZAMENTO', dirs:['U','R','D','L'] },
  { name:'CRUZAMENTO', dirs:['U','R','D','L'] },
  { name:'ECO', dirs:['R'], effect:'ECO' },
  { name:'ECO', dirs:['R'], effect:'ECO' },
  { name:'ECO', dirs:['R'], effect:'ECO' },
  { name:'REVERB', dirs:['R'], effect:'REVERB' },
  { name:'REVERB', dirs:['R'], effect:'REVERB' },
  { name:'REVERB', dirs:['R'], effect:'REVERB' },
];

const DEFAULT_MULT = { flush: 1.4, straight: 1.2, straightFlush: 1.7 };
const DEFAULT_AMP = { eco: 2.0, reverb: 2.0 };
const DEFAULT_FLUSH_MIN = 5;

const STYLES = {
  harmony: { key:'harmony', name:'Mestre da Harmonia', desc:'Flush pode ser ativado com 3 runas.', apply(s){ s.flushMinCount=3; } },
  adapt: { key:'adapt', name:'Mestre da Adapta√ß√£o', desc:'At√© 2 runas por chain ignoram penalidade de giros.', apply(s){ s.styleAdapt=true; } },
  paths: { key:'paths', name:'Mestre dos Caminhos', desc:'+1 vida a cada 2 rompimentos.', apply(s){ s.stylePaths=true; } },
};

const RUNE_TIPS = {
  VAR: "VAR ‚Äî Adapta√ß√£o.\n‚Ä¢ Naipe de coer√™ncia.\n‚Ä¢ Pode ser fortalecido por recompensas.",
  AEL: "AEL ‚Äî Abertura.\n‚Ä¢ Naipe de coer√™ncia.",
  LUM: "LUM ‚Äî Clareza.\n‚Ä¢ Naipe de coer√™ncia.",
  RHE: "RHE ‚Äî V√≠nculo.\n‚Ä¢ Naipe de coer√™ncia.",
  SOL: "SOL ‚Äî Impulso.\n‚Ä¢ Naipe de coer√™ncia.",
  NOX: "NOX ‚Äî Ru√≠do.\n‚Ä¢ Naipe de coer√™ncia."
};
const CONCEPT_TIPS = {
  DESVIO: "DESVIO ‚Äî Direcional.\n‚Ä¢ Dire√ß√µes: ‚Üê ‚Üí\n‚Ä¢ Transmite a chain mudando eixo.\n‚Ä¢ Ocupa espa√ßo e permanece.",
  CURVATURA: "CURVATURA ‚Äî Ramificador.\n‚Ä¢ Dire√ß√µes: ‚Üë ‚Üí\n‚Ä¢ Pode gerar split.\n‚Ä¢ Ocupa espa√ßo e permanece.",
  CRUZAMENTO: "CRUZAMENTO ‚Äî Cruz.\n‚Ä¢ Dire√ß√µes: ‚Üë ‚Üí ‚Üì ‚Üê\n‚Ä¢ Facilita splits e rotas.\n‚Ä¢ Ocupa espa√ßo e permanece.",
  ECO: "ECO ‚Äî Amplificador.\n‚Ä¢ Dire√ß√£o: ‚Üí\n‚Ä¢ Multiplica a runa anterior.\n‚Ä¢ Agora pode stackar m√∫ltiplas vezes na chain.",
  REVERB: "REVERBERA√á√ÉO ‚Äî Amplificador.\n‚Ä¢ Dire√ß√£o: ‚Üí\n‚Ä¢ Multiplica a runa posterior.\n‚Ä¢ Agora pode stackar m√∫ltiplas vezes na chain."
};

/* ===== State ===== */
let state=null;

function uid(){ return Math.random().toString(16).slice(2)+Date.now().toString(16); }
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]];} return a; }
function baseAuraFor(dir){ if(dir==='U')return 3; if(dir==='R')return 2; if(dir==='D')return 1; return 2; }

function buildDeck60(){
  const deck=[];
  for(const rune of RUNES){
    for(const dir of DIRS){
      for(let k=0;k<2;k++){
        deck.push({ id: uid(), kind:'rune', rune, aura: baseAuraFor(dir), dir });
      }
    }
  }
  for(const c of CONCEPTS_12) deck.push({ id: uid(), kind:'concept', ...c });
  return shuffle(deck);
}

function init(){
  state = {
    target:{ r:2, c:2 },
    grid:Array.from({length:N},()=>Array(N).fill(null)),
    blocked:new Set(),
    deck:buildDeck60(),
    discard:[],
    hand:[],
    selectedCardId:null,

    placedThisMove:0,
    currentMoveId:1,

    level:1,
    threshold:BASE_THRESHOLD,
    breaks:0,

    lives:BASE_LIVES,

    auraBoost:Object.fromEntries(RUNES.map(r=>[r,0])),
    globalAuraBonus: 0,
    mult:{...DEFAULT_MULT},
    amp:{...DEFAULT_AMP},
    flushMinCount:DEFAULT_FLUSH_MIN,

    stylesOwned:new Set(),
    styleAdapt:false,
    stylePaths:false,

    tempAuraDebuff:0,

    alive:true,
    inReward:false
  };

  drawToHand();
  render();
  log(`Prot√≥tipo iniciado.\nAlvo: ${posName(state.target.r,state.target.c)} | Limiar: ${state.threshold} | Vidas: ${state.lives}\n`);
}

function applyAllAuraBonusesToCard(card){
  if (!card || card.kind!=='rune') return;
  card.aura = card.aura + (state.auraBoost[card.rune] || 0) + state.globalAuraBonus;
}

function drawOne(){
  if (state.deck.length===0){
    if (state.discard.length===0) return null;
    state.deck = shuffle(state.discard.splice(0));
  }
  return state.deck.pop();
}

function drawToHand(){
  while (state.hand.length < HAND_MAX){
    const c = drawOne();
    if (!c) break;
    if (c.kind==='rune') applyAllAuraBonusesToCard(c);
    state.hand.push(c);
  }
}

function mulligan(){
  state.deck.push(...state.hand);
  state.hand=[];
  shuffle(state.deck);
  state.selectedCardId=null;
  drawToHand();
  log("Mulligan realizado.\n");
}

function inBounds(r,c){ return r>=0 && r<N && c>=0 && c<N; }
function isBorder(r,c){ return r===0 || c===0 || r===N-1 || c===N-1; }
function keyRC(r,c){ return `${r},${c}`; }
function isBlocked(r,c){ return state.blocked.has(keyRC(r,c)); }
function getCard(r,c){ return state.grid[r][c]; }
function prettyDir(d){ return d==='U'?'‚Üë':d==='R'?'‚Üí':d==='D'?'‚Üì':'‚Üê'; }
function posName(r,c){ return `${String.fromCharCode(65+c)}${r+1}`; }

function countConceptsOnGrid(){
  let n=0;
  for(let r=0;r<N;r++) for(let c=0;c<N;c++){
    const card=getCard(r,c);
    if(card && card.kind==='concept') n++;
  }
  return n;
}

function cardTooltip(card){
  if(!card) return "";
  if(card.kind==='rune'){
    const lore = RUNE_TIPS[card.rune] ?? `${card.rune} ‚Äî Runa.`;
    return `${lore}\n\n(Stats)\n‚Ä¢ Aura: ${card.aura}\n‚Ä¢ Dire√ß√£o: ${prettyDir(card.dir)}\n‚Ä¢ B√¥nus global: +${state.globalAuraBonus}\n‚Ä¢ Giros: -25% por 90¬∞`;
  }
  const lore = CONCEPT_TIPS[card.name] ?? `${card.name} ‚Äî Conceito.`;
  const dirs = (card.dirs||[]).map(prettyDir).join(' ');
  return `${lore}\n\n(Stats)\n‚Ä¢ Dire√ß√µes: ${dirs}${card.effect?`\n‚Ä¢ Efeito: ${card.effect}`:''}`;
}

/* ===== Placement / Removal ===== */
function placeSelectedToCell(r,c){
  if(!state.alive || state.inReward) return;
  if(r===state.target.r && c===state.target.c) return;
  if(isBlocked(r,c)){ log(`Casa ${posName(r,c)} bloqueada.\n`, true); return; }
  if(getCard(r,c)) return;

  const id=state.selectedCardId;
  if(!id) return;

  if(state.placedThisMove>=5){ log("Voc√™ j√° colocou 5 cartas nesta rodada.\n", true); return; }

  const idx=state.hand.findIndex(x=>x.id===id);
  if(idx<0) return;

  const card=state.hand.splice(idx,1)[0];
  card._placedMoveId = state.currentMoveId;
  state.grid[r][c]=card;
  state.selectedCardId=null;
  state.placedThisMove+=1;
  render();
}

function removeCardFromCell(r,c){
  if(!state.alive || state.inReward) return;
  const card=getCard(r,c);
  if(!card) return;
  state.grid[r][c]=null;

  if(card._placedMoveId===state.currentMoveId && state.placedThisMove>0) state.placedThisMove-=1;
  delete card._placedMoveId;

  state.hand.push(card);
  render();
}

function clearAllRunesFromGridToDiscard(){
  for(let r=0;r<N;r++) for(let c=0;c<N;c++){
    const card=getCard(r,c);
    if(card && card.kind==='rune'){
      state.discard.push(card);
      state.grid[r][c]=null;
      if(card._placedMoveId===state.currentMoveId && state.placedThisMove>0) state.placedThisMove-=1;
    }
  }
  render();
  log("Runas removidas do grid (foram para o descarte).\n");
}

/* ===== Rendering ===== */
function render(){
  const gridEl=document.getElementById('grid');
  gridEl.innerHTML='';
  for(let r=0;r<N;r++){
    for(let c=0;c<N;c++){
      const isT = (r===state.target.r && c===state.target.c);
      const isB = isBlocked(r,c);

      const cell=document.createElement('div');
      cell.className='cell'+(isT?' target':'')+(isB?' blocked':'');
      cell.dataset.r=r; cell.dataset.c=c;

      const coord=document.createElement('div');
      coord.className='coord mono';
      coord.textContent=`${String.fromCharCode(65+c)}${r+1}`;
      cell.appendChild(coord);

      const card=getCard(r,c);
      const content=document.createElement('div');
      content.className='mono';

      if(isT){
        content.innerHTML=`<div style="font-weight:900;">CASA<br/>DISSONANTE</div><div class="mini">${posName(r,c)}</div>`;
      } else if(!card){
        content.innerHTML=`<div style="opacity:.35;">vazio</div>`;
      } else if(card.kind==='rune'){
        content.innerHTML=`<div style="font-weight:900;">${card.rune}</div><div class="small">a${card.aura} | ${prettyDir(card.dir)}</div>`;
        cell.setAttribute('data-tip', cardTooltip(card));
      } else {
        content.innerHTML=`<div style="font-weight:900;">${card.name}</div><div class="small">conceito</div>`;
        cell.setAttribute('data-tip', cardTooltip(card));
      }
      cell.appendChild(content);

      const badge=document.createElement('div');
      badge.className='badge mono';
      if(card) badge.textContent = card.kind==='rune' ? prettyDir(card.dir) : (card.dirs||[]).map(prettyDir).join('');
      cell.appendChild(badge);

      if(isB){
        const bm=document.createElement('div');
        bm.className='blockedMark';
        bm.textContent='‚úñ';
        cell.appendChild(bm);
      }

      cell.addEventListener('click', ()=>{
        const rr=Number(cell.dataset.r), cc=Number(cell.dataset.c);
        if(rr===state.target.r && cc===state.target.c) return;
        const cardHere=getCard(rr,cc);
        if(cardHere) removeCardFromCell(rr,cc);
        else placeSelectedToCell(rr,cc);
      });

      gridEl.appendChild(cell);
    }
  }

  const handEl=document.getElementById('hand');
  handEl.innerHTML='';
  state.hand.forEach(card=>{
    const d=document.createElement('div');
    d.className='card'+(state.selectedCardId===card.id?' selected':'');
    d.setAttribute('data-tip', cardTooltip(card));

    const tagClass=card.kind==='rune'?'rune':'concept';
    const tagLabel=card.kind==='rune'?'RUNA':'CONCEITO';
    const title=card.kind==='rune'?card.rune:card.name;
    const sub=card.kind==='rune'
      ? `aura ${card.aura} ‚Ä¢ dir ${prettyDir(card.dir)}`
      : `dirs ${(card.dirs||[]).map(prettyDir).join('')} ${card.effect?`‚Ä¢ ${card.effect}`:''}`;

    d.innerHTML=`
      <div class="top">
        <div class="title">${title}</div>
        <div class="tag ${tagClass}">${tagLabel}</div>
      </div>
      <div class="sub mono">${sub}</div>
    `;
    d.addEventListener('click', ()=>{
      if(!state.alive || state.inReward) return;
      state.selectedCardId = (state.selectedCardId===card.id)?null:card.id;
      render();
    });
    handEl.appendChild(d);
  });

  document.getElementById('levelVal').textContent=state.level;
  document.getElementById('breaksVal').textContent=state.breaks;
  document.getElementById('globalAuraVal').textContent=state.globalAuraBonus;
  document.getElementById('livesVal').textContent=state.lives;
  document.getElementById('thresholdVal').textContent=state.threshold;
  document.getElementById('placedThisMove').textContent=state.placedThisMove;

  document.getElementById('deckCount').textContent=state.deck.length;
  document.getElementById('discardCount').textContent=state.discard.length;
  document.getElementById('handCount').textContent=state.hand.length;
  document.getElementById('conceptsOnGrid').textContent=countConceptsOnGrid();

  document.getElementById('mFlush').textContent=state.mult.flush.toFixed(1);
  document.getElementById('mStraight').textContent=state.mult.straight.toFixed(1);
  document.getElementById('mSF').textContent=state.mult.straightFlush.toFixed(1);
  document.getElementById('mEco').textContent=state.amp.eco.toFixed(1);
  document.getElementById('mReverb').textContent=state.amp.reverb.toFixed(1);
  document.getElementById('flushMin').textContent=state.flushMinCount;

  const disable = (!state.alive || state.inReward);
  document.getElementById('btnDraw').disabled=disable;
  document.getElementById('btnMulligan').disabled=disable;
  document.getElementById('btnResolve').disabled=disable;
  document.getElementById('btnClearAllRunes').disabled=disable;
}

/* ===== Chain engine ===== */
function turnsTo(fromDir,toDir){
  const i=DIRS.indexOf(fromDir), j=DIRS.indexOf(toDir);
  const cw=(j-i+4)%4;
  const ccw=(i-j+4)%4;
  return Math.min(cw,ccw);
}
function neighborCoords(r,c){
  return DIRS.map(d=>{
    const [dr,dc]=DELTA[d];
    return { d, r:r+dr, c:c+dc };
  }).filter(x=>inBounds(x.r,x.c));
}
function outgoingAllowed(card,needDir){
  if(!card) return false;
  if(card.kind==='concept') return (card.dirs||[]).includes(needDir);
  if(card.kind==='rune') return true;
  return false;
}

function findAllPaths(maxLen=18){
  const visited=Array.from({length:N},()=>Array(N).fill(false));
  const starts=[];
  for(let r=0;r<N;r++) for(let c=0;c<N;c++){
    if(!isBorder(r,c)) continue;
    if(isBlocked(r,c)) continue;
    if(getCard(r,c)) starts.push({r,c});
  }
  const paths=[];
  function dfs(r,c,path){
    if(path.length>maxLen) return;
    if(r===state.target.r && c===state.target.c){ paths.push([...path]); return; }
    visited[r][c]=true;
    const card=getCard(r,c);
    if(!card){ visited[r][c]=false; return; }

    for(const nb of neighborCoords(r,c)){
      if(visited[nb.r][nb.c]) continue;
      if(isBlocked(nb.r,nb.c)) continue;

      const isTarget=(nb.r===state.target.r && nb.c===state.target.c);
      const nextCard = isTarget ? {} : getCard(nb.r,nb.c);
      if(!isTarget && !nextCard) continue;

      if(!outgoingAllowed(card, nb.d)) continue;

      path.push({r:nb.r,c:nb.c});
      dfs(nb.r,nb.c,path);
      path.pop();
    }
    visited[r][c]=false;
  }
  for(const s of starts) dfs(s.r,s.c,[{r:s.r,c:s.c}]);

  const uniq=new Map();
  for(const p of paths){
    const k=p.map(x=>`${x.r},${x.c}`).join('->');
    if(!uniq.has(k)) uniq.set(k,p);
  }
  return [...uniq.values()];
}

function mostFrequentRuneAtLeast(runes, minCount){
  if(!runes.length) return null;
  const m=new Map();
  for(const r of runes) m.set(r,(m.get(r)||0)+1);
  let best=null,bestN=0;
  for(const [k,v] of m.entries()){
    if(v>bestN){ best=k; bestN=v; }
  }
  return bestN>=minCount?best:null;
}
function round2(x){ return Math.round(x*100)/100; }
function round1(x){ return Math.round(x*10)/10; }

function scorePath(path){
  const cards = path.map(p=>({
    ...p,
    card: (p.r===state.target.r && p.c===state.target.c) ? null : getCard(p.r,p.c)
  }));

  const needs=[];
  for(let i=0;i<cards.length;i++){
    if(i===cards.length-1){ needs.push(null); continue; }
    const a=cards[i], b=cards[i+1];
    const dr=b.r-a.r, dc=b.c-a.c;
    let d=null;
    for(const k of DIRS){
      const [rr,cc]=DELTA[k];
      if(rr===dr && cc===dc){ d=k; break; }
    }
    needs.push(d);
  }

  const runesInChain=[];
  const effective=new Array(cards.length).fill(0);
  const rotTurns=new Array(cards.length).fill(0);

  for(let i=0;i<cards.length;i++){
    const card=cards[i].card;
    const need=needs[i];
    if(!card) continue;
    if(card.kind==='rune'){
      runesInChain.push(card.rune);
      const auraWithDebuff = Math.max(0, card.aura + state.tempAuraDebuff);
      if(!need){
        effective[i]=auraWithDebuff;
      } else {
        const t=turnsTo(card.dir, need);
        rotTurns[i]=t;
        const factor=Math.max(0,1-ROT_PENALTY_PER_TURN*t);
        effective[i]=auraWithDebuff*factor;
      }
    }
  }

  // Style adapt: ignore rotation penalty for up to 2 runes (best savings)
  if(state.styleAdapt){
    const candidates=[];
    for(let i=0;i<cards.length;i++){
      const card=cards[i].card;
      if(!card || card.kind!=='rune') continue;
      if(rotTurns[i]<=0) continue;
      const auraWithDebuff = Math.max(0, card.aura + state.tempAuraDebuff);
      const factor = Math.max(0,1-ROT_PENALTY_PER_TURN*rotTurns[i]);
      const saved = auraWithDebuff*(1-factor);
      candidates.push({i, saved, auraWithDebuff});
    }
    candidates.sort((a,b)=>b.saved-a.saved);
    for(const ch of candidates.slice(0,2)){
      effective[ch.i]=ch.auraWithDebuff;
    }
  }

  // ‚úÖ CHANGE: apply ALL amplifiers found (stacking), not just one
  const ampNotes = [];
  for(let i=0;i<cards.length;i++){
    const card=cards[i].card;
    if(!card || card.kind!=='concept' || !card.effect) continue;

    if(card.effect==='ECO'){
      // multiply previous rune
      for(let j=i-1;j>=0;j--){
        const prev=cards[j].card;
        if(prev && prev.kind==='rune'){
          effective[j]=effective[j]*state.amp.eco;
          ampNotes.push(`ECO √ó${state.amp.eco.toFixed(1)} em ${posName(cards[j].r,cards[j].c)}`);
          break;
        }
      }
    } else if(card.effect==='REVERB'){
      // multiply next rune
      for(let j=i+1;j<cards.length;j++){
        const nxt=cards[j].card;
        if(nxt && nxt.kind==='rune'){
          effective[j]=effective[j]*state.amp.reverb;
          ampNotes.push(`REVERB √ó${state.amp.reverb.toFixed(1)} em ${posName(cards[j].r,cards[j].c)}`);
          break;
        }
      }
    }
  }
  const ampNote = ampNotes.length ? ampNotes.join(' | ') : null;

  const baseSum=effective.reduce((a,b)=>a+b,0);

  const flushRune=mostFrequentRuneAtLeast(runesInChain, state.flushMinCount);
  const isFlush=flushRune!==null;
  const isStraight=true;

  let mult=1.0, tag='Resson√¢ncia Fraca';
  if(isFlush && isStraight){ mult=state.mult.straightFlush; tag='Resson√¢ncia Plena'; }
  else if(isFlush){ mult=state.mult.flush; tag='Resson√¢ncia Coerente'; }
  else if(isStraight){ mult=state.mult.straight; tag='Trajet√≥ria Clara'; }

  const total=baseSum*mult;
  const scaled=Math.round(total*10);

  let entry=null;
  if(path.length>=2){
    const a=path[path.length-2], b=path[path.length-1];
    const dr=b.r-a.r, dc=b.c-a.c;
    for(const k of DIRS){
      const [rr,cc]=DELTA[k];
      if(rr===dr && cc===dc) entry=k;
    }
  }
  return { path, baseSum:round2(baseSum), tag, mult, total:round2(total), scaled, isFlush, flushRune, rotTurns, ampNote, entry };
}

function bestSplitSum(scores){
  const bestByDir=new Map();
  for(const s of scores){
    if(!s.entry) continue;
    const cur=bestByDir.get(s.entry);
    if(!cur || s.scaled>cur.scaled) bestByDir.set(s.entry,s);
  }
  const arr=[...bestByDir.values()].sort((a,b)=>b.scaled-a.scaled);
  const sum=arr.reduce((acc,s)=>acc+s.scaled,0);
  return { sum, chains:arr, dirs:arr.map(x=>x.entry) };
}

/* ===== Dissonance + Rewards (unchanged from last version) ===== */
function weightedPick(items){
  const total=items.reduce((a,b)=>a+b.w,0);
  let r=Math.random()*total;
  for(const it of items){
    r-=it.w;
    if(r<=0) return it.k;
  }
  return items[items.length-1].k;
}
function applyDissonancesIfNeeded(){
  if(state.level%5!==0) return;
  const count=Math.floor(state.level/5);
  const lines=[];
  lines.push(`‚ö° Disson√¢ncias do n√≠vel ${state.level}: ${count}`);

  for(let i=0;i<count;i++){
    const t=weightedPick([{k:'debuff',w:45},{k:'block',w:35},{k:'move',w:20}]);
    if(t==='debuff'){
      state.tempAuraDebuff = Math.min(state.tempAuraDebuff-1,-1);
      lines.push(`‚Ä¢ Ru√≠do ‚Äî aura tempor√°ria ${state.tempAuraDebuff} (pr√≥xima resolu√ß√£o).`);
    } else if(t==='block'){
      const candidates=[];
      for(let r=0;r<N;r++) for(let c=0;c<N;c++){
        if(r===state.target.r && c===state.target.c) continue;
        candidates.push({r,c});
      }
      const pick=candidates[Math.floor(Math.random()*candidates.length)];
      state.blocked.add(`${pick.r},${pick.c}`);
      const card=getCard(pick.r,pick.c);
      if(card){
        if(card.kind==='concept'){ state.grid[pick.r][pick.c]=null; lines.push(`‚Ä¢ Selo ‚Äî bloqueou ${posName(pick.r,pick.c)} e destruiu conceito.`); }
        else { state.discard.push(card); state.grid[pick.r][pick.c]=null; lines.push(`‚Ä¢ Selo ‚Äî bloqueou ${posName(pick.r,pick.c)} e descartou runa.`); }
      } else {
        lines.push(`‚Ä¢ Selo ‚Äî bloqueou ${posName(pick.r,pick.c)}.`);
      }
    } else {
      const occupied=[];
      for(let r=0;r<N;r++) for(let c=0;c<N;c++){
        if(r===state.target.r && c===state.target.c) continue;
        const card=getCard(r,c);
        if(card) occupied.push({r,c});
      }
      if(!occupied.length){
        lines.push(`‚Ä¢ Deslocamento ‚Äî sem pe√ßas para mover.`);
      } else {
        const src=occupied[Math.floor(Math.random()*occupied.length)];
        const options=neighborCoords(src.r,src.c)
          .filter(n=>!(n.r===state.target.r && n.c===state.target.c))
          .filter(n=>!getCard(n.r,n.c))
          .filter(n=>!isBlocked(n.r,n.c));
        if(!options.length){
          lines.push(`‚Ä¢ Deslocamento ‚Äî falhou (sem casa adjacente livre).`);
        } else {
          const dst=options[Math.floor(Math.random()*options.length)];
          state.grid[dst.r][dst.c]=getCard(src.r,src.c);
          state.grid[src.r][src.c]=null;
          lines.push(`‚Ä¢ Deslocamento ‚Äî moveu pe√ßa de ${posName(src.r,src.c)} para ${posName(dst.r,dst.c)}.`);
        }
      }
    }
  }
  log(lines.join('\n')+'\n', true);
}

function generateRewardOption(){
  const styleRemaining = Object.values(STYLES).filter(s=>!state.stylesOwned.has(s.key));
  const cat = weightedPick([
    {k:'aura', w: 60},
    {k:'mult', w: 25},
    {k:'amp',  w: 12},
    {k:'style',w: styleRemaining.length ? 3 : 0}
  ]);

  if(cat==='aura'){
    const rune = RUNES[Math.floor(Math.random()*RUNES.length)];
    return {
      type:'aura',
      rarity:'common',
      title:`Fortificar ${rune}`,
      desc:`+2 aura permanente para todas as cartas ${rune}.\n(afeta cartas compradas daqui em diante)`,
      apply(){
        state.auraBoost[rune]=(state.auraBoost[rune]||0)+2;
        buffExistingRunes(rune,2);
      }
    };
  }

  if(cat==='mult'){
    const which=Math.random()<0.5?'flush':'straight';
    const label=which==='flush'?'Flush':'Straight';
    return {
      type:'mult',
      rarity:'uncommon',
      title:`Resson√¢ncia ‚Äî ${label}`,
      desc:`+0,1 no multiplicador de ${label}.`,
      apply(){
        state.mult[which]=round1(state.mult[which]+0.1);
        state.mult.straightFlush=round1(Math.max(state.mult.straightFlush, state.mult.flush+0.2, state.mult.straight+0.3));
      }
    };
  }

  if(cat==='amp'){
    const which=Math.random()<0.5?'eco':'reverb';
    const label=which==='eco'?'ECO':'REVERB';
    return {
      type:'amp',
      rarity:'rare',
      title:`Amplifica√ß√£o ‚Äî ${label}`,
      desc:`+0,1 no multiplicador do ${label}.`,
      apply(){ state.amp[which]=round1(state.amp[which]+0.1); }
    };
  }

  const remaining=Object.values(STYLES).filter(s=>!state.stylesOwned.has(s.key));
  const chosen=remaining[Math.floor(Math.random()*remaining.length)];
  return {
    type:'style',
    rarity:'mythic',
    title:`Estilo: ${chosen.name}`,
    desc:`${chosen.desc}\n(Pode obter os 3 estilos na mesma run)`,
    apply(){
      state.stylesOwned.add(chosen.key);
      chosen.apply(state);
    }
  };
}

function buffExistingRunes(rune,delta){
  for(const c of state.hand){
    if(c.kind==='rune' && c.rune===rune) c.aura+=delta;
  }
  for(let r=0;r<N;r++) for(let c=0;c<N;c++){
    const card=getCard(r,c);
    if(card && card.kind==='rune' && card.rune===rune) card.aura+=delta;
  }
}
function applyGlobalAuraToExisting(delta){
  for(const c of state.hand){
    if(c.kind==='rune') c.aura += delta;
  }
  for(let r=0;r<N;r++) for(let c=0;c<N;c++){
    const card=getCard(r,c);
    if(card && card.kind==='rune') card.aura += delta;
  }
}

function showRewards(){
  state.inReward=true;
  render();

  document.getElementById('rewardTitle').textContent = `Rompimento ‚Äî Recompensas`;
  document.getElementById('rewardSubtitle').textContent = `N√≠vel: ${state.level} | Limiar: ${state.threshold} | Alvo: ${posName(state.target.r,state.target.c)}`;

  const opts=[], seen=new Set();
  let guard=0;
  while(opts.length<3 && guard<80){
    const o=generateRewardOption();
    const k=`${o.type}:${o.title}`;
    if(!seen.has(k)){ seen.add(k); opts.push(o); }
    guard++;
  }

  const grid=document.getElementById('rewardGrid');
  grid.innerHTML='';
  for(const o of opts){
    const div=document.createElement('div');
    div.className='rewardCard';
    div.innerHTML=`
      <div class="rewardTag ${o.rarity}">${o.rarity.toUpperCase()}</div>
      <div class="rewardTitle">${o.title}</div>
      <div class="rewardDesc">${o.desc}</div>
    `;
    div.addEventListener('click', ()=>{
      o.apply();
      hideRewards();
      log(`üéÅ Recompensa escolhida: ${o.title}\n`, false);
    });
    grid.appendChild(div);
  }

  document.getElementById('rewardOverlay').style.display='flex';
}
function hideRewards(){
  document.getElementById('rewardOverlay').style.display='none';
  state.inReward=false;
  render();
}

function moveTargetAfterBreak(){
  const options=[];
  for(let r=0;r<N;r++) for(let c=0;c<N;c++){
    if(r===state.target.r && c===state.target.c) continue;
    options.push({r,c});
  }
  const nxt=options[Math.floor(Math.random()*options.length)];
  state.target={r:nxt.r,c:nxt.c};

  const card=getCard(nxt.r,nxt.c);
  if(card && card.kind==='concept'){
    state.grid[nxt.r][nxt.c]=null;
    log(`üí• A Casa Dissonante mudou para ${posName(nxt.r,nxt.c)} e destruiu um conceito.\n`, true);
  } else if(card && card.kind==='rune'){
    state.discard.push(card);
    state.grid[nxt.r][nxt.c]=null;
    log(`üí• A Casa Dissonante mudou para ${posName(nxt.r,nxt.c)} e descartou uma runa.\n`, true);
  }
}

/* ===== Resolve ===== */
function consumeAllRunes(){
  for(let r=0;r<N;r++) for(let c=0;c<N;c++){
    const card=getCard(r,c);
    if(card && card.kind==='rune'){
      state.discard.push(card);
      state.grid[r][c]=null;
    }
  }
}

function resolveRound(){
  if(!state.alive || state.inReward) return;
  if(state.lives<=0){ log("Sem vidas restantes.\n", true); return; }

  const paths=findAllPaths();
  if(!paths.length){
    state.lives -= 1;
    state.placedThisMove=0;
    state.currentMoveId += 1;
    drawToHand();
    render();
    log(`Nenhuma chain at√© o alvo (${posName(state.target.r,state.target.c)}). Voc√™ perdeu 1 vida.\n`, true);
    checkEnd();
    return;
  }

  const scores=paths.map(p=>scorePath(p)).sort((a,b)=>b.scaled-a.scaled);
  const split=bestSplitSum(scores);
  const best=scores[0];

  const damage=split.sum;
  const threshold=state.threshold;

  consumeAllRunes();
  state.placedThisMove=0;
  state.currentMoveId += 1;
  drawToHand();
  state.tempAuraDebuff=0;

  const lines=[];
  lines.push(`=== Resolver (N√≠vel ${state.level}) ===`);
  lines.push(`Alvo: ${posName(state.target.r,state.target.c)} | Limiar: ${threshold} | Vidas: ${state.lives}`);
  lines.push(`Chains: ${scores.length}`);
  lines.push(`Melhor chain: ${best.tag}${best.isFlush?` (${best.flushRune})`:''} | base=${best.baseSum} | mult=${best.mult.toFixed(1)} | total=${best.total} | scaled=${best.scaled}`);
  if(best.ampNote) lines.push(`  amps: ${best.ampNote}`);
  lines.push(`Split (dirs ${split.dirs.join(', ')||'‚Äî'}): scaled total = ${damage}`);

  const broke = (damage>=threshold);
  if(broke){
    state.breaks += 1;
    lines.push(`‚úÖ ROMPIMENTO! (${damage} ‚â• ${threshold})`);

    state.globalAuraBonus += 1;
    applyGlobalAuraToExisting(1);
    lines.push(`‚ú® B√¥nus global: todas as runas +1 aura (agora +${state.globalAuraBonus}).`);

    state.level += 1;
    state.threshold += THRESHOLD_STEP;

    if(state.stylePaths && state.breaks % 2 === 0){
      state.lives += 1;
      lines.push(`üåø Mestre dos Caminhos: +1 vida (a cada 2 rompimentos). Vidas: ${state.lives}`);
    }

    moveTargetAfterBreak();
    applyDissonancesIfNeeded();

    render();
    log(lines.join('\n')+'\n', false);
    showRewards();
  } else {
    state.lives -= 1;
    lines.push(`‚ùå Falhou. (${damage} < ${threshold})`);
    lines.push(`Voc√™ perdeu 1 vida. Vidas: ${state.lives}`);
    render();
    log(lines.join('\n')+'\n', true);
    checkEnd();
  }
}

function checkEnd(){
  if(state.lives<=0){
    state.alive=false;
    log(`üíÄ Fim de run. N√≠vel ${state.level} | Rompimentos ${state.breaks}.\n`, true);
    render();
  }
}

/* ===== Help / reward wiring ===== */
function openHelp(){ document.getElementById('helpOverlay').style.display='flex'; }
function closeHelp(){ document.getElementById('helpOverlay').style.display='none'; }

document.getElementById('helpBtn').addEventListener('click', openHelp);
document.getElementById('helpClose').addEventListener('click', closeHelp);
document.getElementById('helpClose2').addEventListener('click', closeHelp);
document.getElementById('helpOverlay').addEventListener('click', (e)=>{ if(e.target.id==='helpOverlay') closeHelp(); });

document.getElementById('rewardSkip').addEventListener('click', ()=>{ hideRewards(); log('(debug) recompensa ignorada.\n', true); });

document.getElementById('btnDraw').addEventListener('click', ()=>{ if(!state.alive||state.inReward) return; drawToHand(); render(); });
document.getElementById('btnMulligan').addEventListener('click', ()=>{ if(!state.alive||state.inReward) return; mulligan(); render(); });
document.getElementById('btnResolve').addEventListener('click', ()=> resolveRound());
document.getElementById('btnClearAllRunes').addEventListener('click', ()=>{ if(!state.alive||state.inReward) return; clearAllRunesFromGridToDiscard(); });
document.getElementById('btnReset').addEventListener('click', ()=> init());

function log(msg, warn=false){
  const el=document.getElementById('log');
  el.textContent = (warn?'‚ö†Ô∏è ':'‚úÖ ') + msg;
}

init();
</script>
</body>
</html>
